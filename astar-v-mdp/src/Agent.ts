import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Light Cycle" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem;
    private scene: Scene;
    
    // Positions
    public position: Vector3;        // Actual world position
    public virtualPosition: Vector3; // "Mental" position (Where it thinks it is in A* mode)
    
    public isStopped: boolean = false;
    public stopReason: 'none' | 'wall' | 'goal' | 'user' = 'none';
    
    private speed: number = 8.0;
    private mode: 'astar' | 'mdp' = 'astar';
    
    // Trail
    private visitedPath: Vector3[] = [];
    private trailMesh: Mesh | null = null;
    private lastGridPos: { x: number, y: number } = { x: -1, y: -1 };

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.2, startY + 0.5); 
        this.virtualPosition = this.position.clone();
        
        this.lastGridPos = { x: startX, y: startY };
        this.visitedPath.push(this.position.clone());

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    public setMode(mode: 'astar' | 'mdp') {
        this.mode = mode;
        // If switching to MDP, sync virtual to real immediately
        if (mode === 'mdp') {
            this.virtualPosition.copyFrom(this.position);
        }
    }

    private createMesh(): Mesh {
        // --- Materials ---
        const bodyMat = new StandardMaterial("bodyMat", this.scene);
        bodyMat.diffuseColor = new Color3(0.1, 0.1, 0.1); 
        bodyMat.specularColor = new Color3(0.5, 0.5, 0.5);
        
        const glowMat = new StandardMaterial("glowMat", this.scene);
        glowMat.emissiveColor = new Color3(0.0, 1.0, 1.0); 
        glowMat.disableLighting = true;

        // --- Geometry ---
        // 1. Main Body (Chassis) - Scaled to fill .75
        const body = MeshBuilder.CreateBox("body", { width: 0.4, height: 0.2, depth: 0.75 }, this.scene);
        body.position.y = 0.2;
        body.material = bodyMat;

        // 2. Wheels (Glowing Rings)
        const wheelOptions = { diameter: 0.4, thickness: 0.08, tessellation: 32 };
        
        const rearWheel = MeshBuilder.CreateTorus("rearWheel", wheelOptions, this.scene);
        rearWheel.rotation.y = Math.PI / 2; 
        rearWheel.position.z = -0.3; 
        rearWheel.position.y = 0.2;
        rearWheel.material = glowMat;

        const frontWheel = MeshBuilder.CreateTorus("frontWheel", wheelOptions, this.scene);
        frontWheel.rotation.y = Math.PI / 2;
        frontWheel.position.z = 0.3; 
        frontWheel.position.y = 0.2;
        frontWheel.material = glowMat;
        
        // 3. Light Strips
        const stripLeft = MeshBuilder.CreateBox("stripL", { width: 0.03, height: 0.03, depth: 0.5 }, this.scene);
        stripLeft.position.x = -0.2;
        stripLeft.position.y = 0.2;
        stripLeft.material = glowMat;

        const stripRight = MeshBuilder.CreateBox("stripR", { width: 0.03, height: 0.03, depth: 0.5 }, this.scene);
        stripRight.position.x = 0.2;
        stripRight.position.y = 0.2;
        stripRight.material = glowMat;

        const vehicle = Mesh.MergeMeshes([body, rearWheel, frontWheel, stripLeft, stripRight], true, true, undefined, false, true)!;
        vehicle.name = "agentCycle";
        
        return vehicle;
    }

    public update(deltaTime: number, solver: Solver): void {
        if (this.isStopped) return;

        // --- 1. Trail Logic ---
        const currentGridX = Math.floor(this.position.x);
        const currentGridZ = Math.floor(this.position.z);
        
        if (currentGridX !== this.lastGridPos.x || currentGridZ !== this.lastGridPos.y) {
            this.visitedPath.push(new Vector3(currentGridX + 0.5, 0.2, currentGridZ + 0.5));
            this.lastGridPos = { x: currentGridX, y: currentGridZ };
        }
        this.updateTrail();

        // --- 2. Determine Planning Position ---
        if (this.mode === 'mdp') {
            this.virtualPosition.copyFrom(this.position);
        }
        
        // Use Virtual Position to query the Policy (Brain)
        const vGridX = Math.floor(this.virtualPosition.x);
        const vGridZ = Math.floor(this.virtualPosition.z);

        // --- 3. Calculate Command Velocity (Intention) ---
        let vxCommand = 0;
        let vzCommand = 0;
        
        if (this.gridSystem.isValid(vGridX, vGridZ)) {
            // Check Goal (Virtual Parking)
            const cellType = this.gridSystem.getCell(vGridX, vGridZ);
            if (cellType === CellType.Goal) {
                 const targetX = vGridX + 0.5;
                 const targetZ = vGridZ + 0.5;
                 const dx = targetX - this.virtualPosition.x;
                 const dz = targetZ - this.virtualPosition.z;
                 const dist = Math.sqrt(dx * dx + dz * dz);
                 
                 if (dist > 0.05) {
                     vxCommand = (dx / dist) * this.speed;
                     vzCommand = (dz / dist) * this.speed;
                 }
                 // Else stop virtually
            } else {
                // Policy
                const index = this.gridSystem.getFlatIndex(vGridX, vGridZ);
                const targetAngle = solver.policy[index];
                vxCommand = Math.cos(targetAngle) * this.speed;
                vzCommand = Math.sin(targetAngle) * this.speed;
            }
        }
        // If invalid (out of bounds), command is 0, but physics continues to resolve collision with edge.

        // --- 4. Update Virtual Position (Perfect Execution) ---
        this.virtualPosition.x += vxCommand * deltaTime;
        this.virtualPosition.z += vzCommand * deltaTime;

        // --- 5. Calculate Real Forces (Physics) ---
        const rGridX = Math.floor(this.position.x);
        const rGridZ = Math.floor(this.position.z);
        
        // Check Goal (Real) - Stop Simulation
        if (this.gridSystem.isValid(rGridX, rGridZ) && this.gridSystem.getCell(rGridX, rGridZ) === CellType.Goal) {
             const targetX = rGridX + 0.5;
             const targetZ = rGridZ + 0.5;
             const dx = targetX - this.position.x;
             const dz = targetZ - this.position.z;
             const dist = Math.sqrt(dx * dx + dz * dz);
             
             if (dist < 0.05) {
                 this.position.x = targetX;
                 this.position.z = targetZ;
                 this.updateMeshPosition();
                 this.updateTrail();
                 this.isStopped = true; // STOP SIMULATION
                 this.stopReason = 'goal';
                 return; 
             }
        }

        const windVec = this.gridSystem.getWindVector(rGridX, rGridZ);
        let vxWind = 0;
        let vzWind = 0;
        
        if (Math.abs(windVec.x) > 0.01 || Math.abs(windVec.y) > 0.01) {
            const windMultiplier = 4.0;
            vxWind = windVec.x * windMultiplier;
            vzWind = windVec.y * windMultiplier;
        } else {
            // Jitter
            vxWind += (Math.random() - 0.5) * 0.5;
            vzWind += (Math.random() - 0.5) * 0.5;
        }

        const totalVx = vxCommand + vxWind;
        const totalVz = vzCommand + vzWind;

        // 6. Integrate & Collision (Sliding with Radius)
        const radius = 0.05;
        const epsilon = 0.001;
        
        // --- X Axis ---
        let nextX = this.position.x + totalVx * deltaTime;
        let checkX = totalVx > 0 ? nextX + radius : nextX - radius;
        let gridXCheck = Math.floor(checkX);
        let gridZCheck = Math.floor(this.position.z);
        
        let colX = false;
        if (this.gridSystem.isValid(gridXCheck, gridZCheck)) {
            if (this.gridSystem.getCell(gridXCheck, gridZCheck) === CellType.Wall) {
                colX = true;
            }
        } else {
            colX = true; // Hit Edge
        }
        
        if (colX) {
            if (totalVx > 0) nextX = gridXCheck - radius - epsilon;
            else nextX = gridXCheck + 1 + radius + epsilon;
            this.isStopped = true; // Hit Wall/Edge
            this.stopReason = 'wall';
        }
        this.position.x = nextX;

        // --- Z Axis ---
        let nextZ = this.position.z + totalVz * deltaTime;
        let checkZ = totalVz > 0 ? nextZ + radius : nextZ - radius;
        gridXCheck = Math.floor(this.position.x);
        gridZCheck = Math.floor(checkZ);
        
        let colZ = false;
        if (this.gridSystem.isValid(gridXCheck, gridZCheck)) {
            if (this.gridSystem.getCell(gridXCheck, gridZCheck) === CellType.Wall) {
                colZ = true;
            }
        } else {
            colZ = true; // Hit Edge
        }
        
        if (colZ) {
            if (totalVz > 0) nextZ = gridZCheck - radius - epsilon;
            else nextZ = gridZCheck + 1 + radius + epsilon;
            this.isStopped = true; // Hit Wall/Edge
            this.stopReason = 'wall';
        }
        this.position.z = nextZ;

        this.updateMeshPosition();
        
        // Rotation (Face Actual Movement)
        if (Math.abs(totalVx) > 0.1 || Math.abs(totalVz) > 0.1) {
            const targetPos = this.mesh.position.add(new Vector3(totalVx, 0, totalVz));
            this.mesh.lookAt(targetPos);
        }
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    private updateTrail(): void {
        if (this.visitedPath.length === 0) return;
        
        // Construct points: History + Current Position
        const points = [...this.visitedPath, this.position];
        
        if (points.length < 2) return;

        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
        
        this.trailMesh = MeshBuilder.CreateTube("trail", {
            path: points,
            radius: 0.05,
            tessellation: 6, // Low-poly tube for performance
            cap: Mesh.NO_CAP,
            updatable: false 
        }, this.scene);
        
        const mat = new StandardMaterial("trailMat", this.scene);
        mat.emissiveColor = new Color3(0.0, 1.0, 1.0); // Cyan
        mat.disableLighting = true;
        this.trailMesh.material = mat;
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.virtualPosition.copyFrom(this.position); 
        
        this.isStopped = false;
        this.stopReason = 'none';
        this.lastGridPos = { x, y };
        
        this.visitedPath = [this.position.clone()];
        if (this.trailMesh) {
            this.trailMesh.dispose();
            this.trailMesh = null;
        }
        
        this.updateMeshPosition();
    }

    public dispose(): void {
        this.mesh.dispose();
        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
    }
}