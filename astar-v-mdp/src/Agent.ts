import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Light Drone" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem;
    private scene: Scene;
    
    // Positions
    public position: Vector3;        // Actual world position
    public virtualPosition: Vector3; // "Mental" position (Where it thinks it is in A* mode)
    
    public isStopped: boolean = false;
    public stopReason: 'none' | 'wall' | 'goal' | 'user' = 'none';
    
    private speed: number = 7.0;
    private mode: 'astar' | 'mdp' = 'astar';
    
    // Trail
    private visitedPath: Vector3[] = [];
    private trailMesh: Mesh | null = null;
    private lastGridPos: { x: number, y: number } = { x: -1, y: -1 };
    
    // Animation
    private propellers: Mesh[] = [];

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.4, startY + 0.5); // Fly higher (0.4)
        this.virtualPosition = this.position.clone();
        
        this.lastGridPos = { x: startX, y: startY };
        this.visitedPath.push(this.position.clone());

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    public setMode(mode: 'astar' | 'mdp') {
        this.mode = mode;
        // If switching to MDP, sync virtual to real immediately
        if (mode === 'mdp') {
            this.virtualPosition.copyFrom(this.position);
        }
    }

    private createMesh(): Mesh {
        // --- Materials ---
        const bodyMat = new StandardMaterial("bodyMat", this.scene);
        bodyMat.diffuseColor = Color3.FromHexString("#F4CB38"); // Muted Yellow
        bodyMat.emissiveColor = Color3.FromHexString("#F4CB38").scale(0.4); 
        bodyMat.specularColor = new Color3(0.5, 0.5, 0.5);
        
        const glowMat = new StandardMaterial("glowMat", this.scene);
        glowMat.emissiveColor = Color3.FromHexString("#4cf083"); 
        glowMat.disableLighting = false;

        const propMat = new StandardMaterial("propMat", this.scene);
        propMat.diffuseColor = Color3.FromHexString("#ffffff");
        propMat.emissiveColor = Color3.FromHexString("#ffffff").scale(0.5); // Dim glow

        // --- Geometry ---
        // 1. Central Body
        const body = MeshBuilder.CreateBox("body", { width: 0.25, height: 0.15, depth: 0.35 }, this.scene);
        body.material = bodyMat;

        // 2. Arms (X-Shape)
        const arm1 = MeshBuilder.CreateBox("arm1", { width: 0.8, height: 0.04, depth: 0.08 }, this.scene);
        arm1.rotation.y = Math.PI / 4;
        arm1.material = bodyMat;

        const arm2 = MeshBuilder.CreateBox("arm2", { width: 0.8, height: 0.04, depth: 0.08 }, this.scene);
        arm2.rotation.y = -Math.PI / 4;
        arm2.material = bodyMat;

        // 3. Propellers & Motors
        this.propellers = [];
        const propOffsets = [
            new Vector3(0.28, 0.05, 0.28),   // FL
            new Vector3(-0.28, 0.05, 0.28),  // FR
            new Vector3(0.28, 0.05, -0.28),  // BL
            new Vector3(-0.28, 0.05, -0.28)  // BR
        ];

        const motors: Mesh[] = [];
        propOffsets.forEach((offset, i) => {
             // Motor
             const motor = MeshBuilder.CreateCylinder("motor"+i, { height: 0.1, diameter: 0.1 }, this.scene);
             motor.position.copyFrom(offset);
             motor.position.y -= 0.02;
             motor.material = bodyMat;
             motors.push(motor);

             // Prop Blade
             const prop = MeshBuilder.CreateBox("prop"+i, { width: 0.35, height: 0.01, depth: 0.04 }, this.scene);
             prop.position.copyFrom(offset);
             prop.position.y += 0.05; // Sit on top of motor
             prop.material = propMat;
             this.propellers.push(prop);
        });

        // 4. Direction Indicator (Eye/Cone at front)
        // Drone faces +Z (local). 
        const eye = MeshBuilder.CreateBox("eye", { width: 0.15, height: 0.05, depth: 0.05 }, this.scene);
        eye.position.z = 0.18; // Front face
        eye.position.y = 0.02;
        eye.material = glowMat;

        // Merge static parts (Body, Arms, Motors, Eye)
        const staticParts = [body, arm1, arm2, eye, ...motors];
        const chassis = Mesh.MergeMeshes(staticParts, true, true, undefined, false, true)!;
        
        // Parent propellers to chassis
        chassis.name = "droneChassis";
        this.propellers.forEach(p => {
            p.parent = chassis;
        });

        return chassis;
    }

    public update(deltaTime: number, solver: Solver, isRunning: boolean): void {
        // Animate Props (Spin even if movement is stopped)
        this.propellers.forEach((p, i) => {
            const dir = i % 2 === 0 ? 1 : -1;
            const rotationSpeed = 30 * deltaTime * dir;
            
            if (p.rotationQuaternion) {
                const euler = p.rotationQuaternion.toEulerAngles();
                euler.y += rotationSpeed;
                p.rotationQuaternion.copyFrom(euler.toQuaternion());
            } else {
                p.rotation.y += rotationSpeed;
            }
        });

        if (!isRunning || this.isStopped) return;

        // --- 1. Trail Logic ---
        const currentGridX = Math.floor(this.position.x);
        const currentGridZ = Math.floor(this.position.z);
        
        if (currentGridX !== this.lastGridPos.x || currentGridZ !== this.lastGridPos.y) {
            this.visitedPath.push(new Vector3(currentGridX + 0.5, 0.2, currentGridZ + 0.5));
            this.lastGridPos = { x: currentGridX, y: currentGridZ };
        }
        this.updateTrail();

        // --- 2. Determine Planning Position ---
        if (this.mode === 'mdp') {
            this.virtualPosition.copyFrom(this.position);
        }
        
        // Use Virtual Position to query the Policy (Brain)
        const vGridX = Math.floor(this.virtualPosition.x);
        const vGridZ = Math.floor(this.virtualPosition.z);

        // --- 3. Calculate Command Velocity (Intention) ---
        let vxCommand = 0;
        let vzCommand = 0;
        
        if (this.gridSystem.isValid(vGridX, vGridZ)) {
            // Check Goal (Virtual Parking)
            const cellType = this.gridSystem.getCell(vGridX, vGridZ);
            if (cellType === CellType.Goal) {
                 const targetX = vGridX + 0.5;
                 const targetZ = vGridZ + 0.5;
                 const dx = targetX - this.virtualPosition.x;
                 const dz = targetZ - this.virtualPosition.z;
                 const dist = Math.sqrt(dx * dx + dz * dz);
                 
                 if (dist > 0.05) {
                     vxCommand = (dx / dist) * this.speed;
                     vzCommand = (dz / dist) * this.speed;
                 }
                 // Else stop virtually
            } else {
                // Policy
                const index = this.gridSystem.getFlatIndex(vGridX, vGridZ);
                const targetAngle = solver.policy[index];
                vxCommand = Math.cos(targetAngle) * this.speed;
                vzCommand = Math.sin(targetAngle) * this.speed;

                // --- Lane Centering Force ---
                // Prevents the agent from grazing walls when moving through narrow gaps
                // by nudging it toward the center of the current tile's path.
                const centeringGain = 5.0; 
                const isHorizontal = Math.abs(vxCommand) > Math.abs(vzCommand);
                
                if (isHorizontal) {
                    // Nudge towards the vertical center of the row
                    const targetZ = vGridZ + 0.5;
                    const errorZ = targetZ - (this.mode === 'mdp' ? this.position.z : this.virtualPosition.z);
                    vzCommand += errorZ * centeringGain;
                } else {
                    // Nudge towards the horizontal center of the column
                    const targetX = vGridX + 0.5;
                    const errorX = targetX - (this.mode === 'mdp' ? this.position.x : this.virtualPosition.x);
                    vxCommand += errorX * centeringGain;
                }
            }
        }
        // If invalid (out of bounds), command is 0, but physics continues to resolve collision with edge.

        // --- 4. Update Virtual Position (Perfect Execution) ---
        this.virtualPosition.x += vxCommand * deltaTime;
        this.virtualPosition.z += vzCommand * deltaTime;

        // --- 5. Calculate Real Forces (Physics) ---
        const rGridX = Math.floor(this.position.x);
        const rGridZ = Math.floor(this.position.z);
        
        // Check Goal (Real) - Stop Simulation
        if (this.gridSystem.isValid(rGridX, rGridZ) && this.gridSystem.getCell(rGridX, rGridZ) === CellType.Goal) {
             const targetX = rGridX + 0.5;
             const targetZ = rGridZ + 0.5;
             const dx = targetX - this.position.x;
             const dz = targetZ - this.position.z;
             const dist = Math.sqrt(dx * dx + dz * dz);
             
             if (dist < 0.05) {
                 this.position.x = targetX;
                 this.position.z = targetZ;
                 this.updateMeshPosition();
                 this.updateTrail();
                 this.isStopped = true; // STOP SIMULATION
                 this.stopReason = 'goal';
                 return; 
             }
        }

        const windVec = this.gridSystem.getWindVector(rGridX, rGridZ);
        let vxWind = 0;
        let vzWind = 0;
        
        if (Math.abs(windVec.x) > 0.01 || Math.abs(windVec.y) > 0.01) {
            const windMultiplier = 4.0;
            vxWind = windVec.x * windMultiplier;
            vzWind = windVec.y * windMultiplier;
        } else {
            // Jitter
            vxWind += (Math.random() - 0.5) * 0.5;
            vzWind += (Math.random() - 0.5) * 0.5;
        }

        const totalVx = vxCommand + vxWind;
        const totalVz = vzCommand + vzWind;

        // 6. Integrate & Collision (Sliding with Radius)
        const radius = 0.05;
        const epsilon = 0.001;
        
        // --- X Axis ---
        let nextX = this.position.x + totalVx * deltaTime;
        let checkX = totalVx > 0 ? nextX + radius : nextX - radius;
        let gridXCheck = Math.floor(checkX);
        let gridZCheck = Math.floor(this.position.z);
        
        let colX = false;
        if (this.gridSystem.isValid(gridXCheck, gridZCheck)) {
            if (this.gridSystem.getCell(gridXCheck, gridZCheck) === CellType.Wall) {
                colX = true;
            }
        } else {
            colX = true; // Hit Edge
        }
        
        if (colX) {
            if (totalVx > 0) nextX = gridXCheck - radius - epsilon;
            else nextX = gridXCheck + 1 + radius + epsilon;
            this.isStopped = true; // Hit Wall/Edge
            this.stopReason = 'wall';
        }
        this.position.x = nextX;

        // --- Z Axis ---
        let nextZ = this.position.z + totalVz * deltaTime;
        let checkZ = totalVz > 0 ? nextZ + radius : nextZ - radius;
        gridXCheck = Math.floor(this.position.x);
        gridZCheck = Math.floor(checkZ);
        
        let colZ = false;
        if (this.gridSystem.isValid(gridXCheck, gridZCheck)) {
            if (this.gridSystem.getCell(gridXCheck, gridZCheck) === CellType.Wall) {
                colZ = true;
            }
        } else {
            colZ = true; // Hit Edge
        }
        
        if (colZ) {
            if (totalVz > 0) nextZ = gridZCheck - radius - epsilon;
            else nextZ = gridZCheck + 1 + radius + epsilon;
            this.isStopped = true; // Hit Wall/Edge
            this.stopReason = 'wall';
        }
        this.position.z = nextZ;

        this.updateMeshPosition();
        
        // Rotation (Face Actual Movement)
        if (Math.abs(totalVx) > 0.1 || Math.abs(totalVz) > 0.1) {
            const targetPos = this.mesh.position.add(new Vector3(totalVx, 0, totalVz));
            this.mesh.lookAt(targetPos);
        }
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    private updateTrail(): void {
        if (this.visitedPath.length === 0) return;
        
        // Construct points: History + Current Position
        const points = [...this.visitedPath, this.position];
        
        if (points.length < 2) return;

        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
        
        this.trailMesh = MeshBuilder.CreateTube("trail", {
            path: points,
            radius: 0.05,
            tessellation: 6, // Low-poly tube for performance
            cap: Mesh.NO_CAP,
            updatable: false 
        }, this.scene);
        
        const mat = new StandardMaterial("trailMat", this.scene);
        mat.emissiveColor = Color3.FromHexString("#4cc9f0"); // Sky Aqua
        mat.disableLighting = true;
        this.trailMesh.material = mat;
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.virtualPosition.copyFrom(this.position); 
        
        this.isStopped = false;
        this.stopReason = 'none';
        this.lastGridPos = { x, y };
        
        this.visitedPath = [this.position.clone()];
        if (this.trailMesh) {
            this.trailMesh.dispose();
            this.trailMesh = null;
        }
        
        this.updateMeshPosition();
    }

    public dispose(): void {
        this.mesh.dispose();
        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
    }
}