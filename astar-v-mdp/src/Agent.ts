import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Light Cycle" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem;
    private scene: Scene;
    public position: Vector3;
    private speed: number = 8.0;
    
    // Trail
    private visitedPath: Vector3[] = [];
    private trailMesh: Mesh | null = null;
    private lastGridPos: { x: number, y: number } = { x: -1, y: -1 };

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.2, startY + 0.5); 
        this.lastGridPos = { x: startX, y: startY };
        this.visitedPath.push(this.position.clone());

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    private createMesh(): Mesh {
        // --- Materials ---
        const bodyMat = new StandardMaterial("bodyMat", this.scene);
        bodyMat.diffuseColor = new Color3(0.1, 0.1, 0.1); // Black Body
        bodyMat.specularColor = new Color3(0.5, 0.5, 0.5);
        
        const glowMat = new StandardMaterial("glowMat", this.scene);
        glowMat.emissiveColor = new Color3(0.0, 1.0, 1.0); // Cyan Glow
        glowMat.disableLighting = true;

        // --- Geometry ---
        // 1. Main Body (Chassis) - Scaled to fill .75
        const body = MeshBuilder.CreateBox("body", { width: 0.4, height: 0.2, depth: 0.75 }, this.scene);
        body.position.y = 0.2;
        body.material = bodyMat;

        // 2. Wheels (Glowing Rings) - Larger diameter
        const wheelOptions = { diameter: 0.4, thickness: 0.08, tessellation: 32 };
        
        const rearWheel = MeshBuilder.CreateTorus("rearWheel", wheelOptions, this.scene);
        rearWheel.rotation.y = Math.PI / 2; 
        rearWheel.position.z = -0.3; // Adjusted for 0.75 depth
        rearWheel.position.y = 0.2;
        rearWheel.material = glowMat;

        const frontWheel = MeshBuilder.CreateTorus("frontWheel", wheelOptions, this.scene);
        frontWheel.rotation.y = Math.PI / 2;
        frontWheel.position.z = 0.3; // Adjusted for 0.75 depth
        frontWheel.position.y = 0.2;
        frontWheel.material = glowMat;
        
        // 3. Light Strips (Side)
        const stripLeft = MeshBuilder.CreateBox("stripL", { width: 0.03, height: 0.03, depth: 0.5 }, this.scene);
        stripLeft.position.x = -0.2;
        stripLeft.position.y = 0.2;
        stripLeft.material = glowMat;

        const stripRight = MeshBuilder.CreateBox("stripR", { width: 0.03, height: 0.03, depth: 0.5 }, this.scene);
        stripRight.position.x = 0.2;
        stripRight.position.y = 0.2;
        stripRight.material = glowMat;

        // Merge all into one mesh
        const vehicle = Mesh.MergeMeshes([body, rearWheel, frontWheel, stripLeft, stripRight], true, true, undefined, false, true)!;
        vehicle.name = "agentCycle";
        
        return vehicle;
    }

    public update(deltaTime: number, solver: Solver): void {
        // 1. Get current grid cell
        const gridX = Math.floor(this.position.x);
        const gridZ = Math.floor(this.position.z);

        if (!this.gridSystem.isValid(gridX, gridZ)) {
            return;
        }
        
        // --- Trail Logic ---
        if (gridX !== this.lastGridPos.x || gridZ !== this.lastGridPos.y) {
            this.visitedPath.push(new Vector3(gridX + 0.5, 0.2, gridZ + 0.5));
            this.lastGridPos = { x: gridX, y: gridZ };
        }
        this.updateTrail();

        const cellType = this.gridSystem.getCell(gridX, gridZ);
        let vx = 0;
        let vz = 0;

        // 2. Behavior based on cell type
        if (cellType === CellType.Goal) {
            // Parking Logic
            const targetX = gridX + 0.5;
            const targetZ = gridZ + 0.5;
            const dx = targetX - this.position.x;
            const dz = targetZ - this.position.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < 0.05) {
                this.position.x = targetX;
                this.position.z = targetZ;
                this.updateMeshPosition();
                this.updateTrail(); // Final update
                return; // Stop
            } else {
                vx = (dx / dist) * this.speed;
                vz = (dz / dist) * this.speed;
            }
        } else {
            // 3. Base Movement
            const index = this.gridSystem.getFlatIndex(gridX, gridZ);
            const targetAngle = solver.policy[index];
            
            vx = Math.cos(targetAngle) * this.speed;
            vz = Math.sin(targetAngle) * this.speed;

            // 4. Wind
            const windVec = this.gridSystem.getWindVector(gridX, gridZ);
            const hasWind = (Math.abs(windVec.x) > 0.01 || Math.abs(windVec.y) > 0.01);

            if (hasWind) {
                const windMultiplier = 4.0;
                vx += windVec.x * windMultiplier;
                vz += windVec.y * windMultiplier;
            } else {
                 vx += (Math.random() - 0.5) * 0.5;
                 vz += (Math.random() - 0.5) * 0.5;
            }
        }

        // 5. Integrate
        const nextX = this.position.x + vx * deltaTime;
        const nextZ = this.position.z + vz * deltaTime;

        // 6. Wall Collision
        const nextGridX = Math.floor(nextX);
        const nextGridZ = Math.floor(nextZ);
        
        if (this.gridSystem.isValid(nextGridX, nextGridZ)) {
             const nextCell = this.gridSystem.getCell(nextGridX, nextGridZ);
             if (nextCell !== CellType.Wall) {
                 this.position.x = nextX;
                 this.position.z = nextZ;
             }
        }

        this.updateMeshPosition();
        
        // 7. Rotation
        if (Math.abs(vx) > 0.1 || Math.abs(vz) > 0.1) {
            const targetPos = this.mesh.position.add(new Vector3(vx, 0, vz));
            this.mesh.lookAt(targetPos);
        }
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    private updateTrail(): void {
        if (this.visitedPath.length === 0) return;
        
        // Construct points: History + Current Position
        const points = [...this.visitedPath, this.position];
        
        // If only 1 point (start), we can't make a tube. Need at least 2.
        if (points.length < 2) return;

        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
        
        this.trailMesh = MeshBuilder.CreateTube("trail", {
            path: points,
            radius: 0.05,
            updatable: false 
        }, this.scene);
        
        const mat = new StandardMaterial("trailMat", this.scene);
        mat.emissiveColor = new Color3(0.0, 1.0, 1.0); // Cyan
        mat.disableLighting = true;
        this.trailMesh.material = mat;
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.lastGridPos = { x, y };
        
        this.visitedPath = [this.position.clone()];
        if (this.trailMesh) {
            this.trailMesh.dispose();
            this.trailMesh = null;
        }
        
        this.updateMeshPosition();
    }
}