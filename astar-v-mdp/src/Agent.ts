import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Light Drone" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem;
    private scene: Scene;
    
    // Positions
    public position: Vector3;        // Actual world position
    public virtualPosition: Vector3; // "Mental" position (Where it thinks it is in A* mode)
    
    public isStopped: boolean = false;
    public stopReason: 'none' | 'wall' | 'goal' | 'user' = 'none';
    
    private speed: number = 7.0;
    private mode: 'astar' | 'mdp' = 'astar';
    
    // Trail
    private visitedPath: Vector3[] = [];
    private trailMesh: Mesh | null = null;
    private lastGridPos: { x: number, y: number } = { x: -1, y: -1 };
    
    // Animation
    private propellers: Mesh[] = [];
    private trailMaterial: StandardMaterial;

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.4, startY + 0.5); // Fly higher (0.4)
        this.virtualPosition = this.position.clone();
        
        this.lastGridPos = { x: startX, y: startY };
        // Initial trail point at ground height
        this.visitedPath = [new Vector3(startX + 0.5, 0.03, startY + 0.5)];

        // Create persistent material for the trail (Tron Blue)
        this.trailMaterial = new StandardMaterial("trailMat", this.scene);
        this.trailMaterial.emissiveColor = Color3.FromHexString("#4cc9f0"); 
        this.trailMaterial.disableLighting = true;

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    public setMode(mode: 'astar' | 'mdp') {
        this.mode = mode;
        // If switching to MDP, sync virtual to real immediately
        if (mode === 'mdp') {
            this.virtualPosition.copyFrom(this.position);
        }
    }

    private createMesh(): Mesh {
        // --- Materials ---
        const bodyMat = new StandardMaterial("bodyMat", this.scene);
        bodyMat.diffuseColor = Color3.FromHexString("#F4CB38"); // Muted Yellow
        bodyMat.emissiveColor = Color3.FromHexString("#F4CB38").scale(0.4); 
        bodyMat.specularColor = new Color3(0.5, 0.5, 0.5);
        
        const glowMat = new StandardMaterial("glowMat", this.scene);
        glowMat.emissiveColor = Color3.FromHexString("#4cf083"); 
        glowMat.disableLighting = false;

        const propMat = new StandardMaterial("propMat", this.scene);
        propMat.diffuseColor = Color3.FromHexString("#ffffff");
        propMat.emissiveColor = Color3.FromHexString("#ffffff").scale(0.5); // Dim glow

        // --- Geometry ---
        // 1. Central Body
        const body = MeshBuilder.CreateBox("body", { width: 0.25, height: 0.15, depth: 0.35 }, this.scene);
        body.material = bodyMat;

        // 2. Arms (X-Shape)
        const arm1 = MeshBuilder.CreateBox("arm1", { width: 0.8, height: 0.04, depth: 0.08 }, this.scene);
        arm1.rotation.y = Math.PI / 4;
        arm1.material = bodyMat;

        const arm2 = MeshBuilder.CreateBox("arm2", { width: 0.8, height: 0.04, depth: 0.08 }, this.scene);
        arm2.rotation.y = -Math.PI / 4;
        arm2.material = bodyMat;

        // 3. Propellers & Motors
        this.propellers = [];
        const propOffsets = [
            new Vector3(0.28, 0.05, 0.28),   // FL
            new Vector3(-0.28, 0.05, 0.28),  // FR
            new Vector3(0.28, 0.05, -0.28),  // BL
            new Vector3(-0.28, 0.05, -0.28)  // BR
        ];

        const motors: Mesh[] = [];
        propOffsets.forEach((offset, i) => {
             // Motor
             const motor = MeshBuilder.CreateCylinder("motor"+i, { height: 0.1, diameter: 0.1 }, this.scene);
             motor.position.copyFrom(offset);
             motor.position.y -= 0.02;
             motor.material = bodyMat;
             motors.push(motor);

             // Prop Blade
             const prop = MeshBuilder.CreateBox("prop"+i, { width: 0.35, height: 0.01, depth: 0.04 }, this.scene);
             prop.position.copyFrom(offset);
             prop.position.y += 0.05; // Sit on top of motor
             prop.material = propMat;
             this.propellers.push(prop);
        });

        // 4. Direction Indicator (Eye/Cone at front)
        // Drone faces +Z (local). 
        const eye = MeshBuilder.CreateBox("eye", { width: 0.15, height: 0.05, depth: 0.05 }, this.scene);
        eye.position.z = 0.18; // Front face
        eye.position.y = 0.02;
        eye.material = glowMat;

        // Merge static parts (Body, Arms, Motors, Eye)
        const staticParts = [body, arm1, arm2, eye, ...motors];
        const chassis = Mesh.MergeMeshes(staticParts, true, true, undefined, false, true)!;
        
        // Parent propellers to chassis
        chassis.name = "droneChassis";
        this.propellers.forEach(p => {
            p.parent = chassis;
        });

        return chassis;
    }

    public update(deltaTime: number, solver: Solver, isRunning: boolean): void {
        // --- 1. Animate Props (Always) ---
        this.propellers.forEach((p, i) => {
            const dir = i % 2 === 0 ? 1 : -1;
            const rotationSpeed = 30 * deltaTime * dir;
            
            if (p.rotationQuaternion) {
                const euler = p.rotationQuaternion.toEulerAngles();
                euler.y += rotationSpeed;
                p.rotationQuaternion.copyFrom(euler.toQuaternion());
            } else {
                p.rotation.y += rotationSpeed;
            }
        });

        // --- 2. Movement Logic (Only when running) ---
        if (isRunning && !this.isStopped) {
            // --- Trail History ---
            const currentGridX = Math.floor(this.position.x);
            const currentGridZ = Math.floor(this.position.z);
            
            if (currentGridX !== this.lastGridPos.x || currentGridZ !== this.lastGridPos.y) {
                // Push point at ground height
                this.visitedPath.push(new Vector3(currentGridX + 0.5, 0.03, currentGridZ + 0.5));
                this.lastGridPos = { x: currentGridX, y: currentGridZ };
            }

            // --- Determine Planning Position ---
            if (this.mode === 'mdp') {
                this.virtualPosition.copyFrom(this.position);
            }
            
            const vGridX = Math.floor(this.virtualPosition.x);
            const vGridZ = Math.floor(this.virtualPosition.z);

            // --- Calculate Command Velocity (Intention) ---
            let vxCommand = 0;
            let vzCommand = 0;
            
            if (this.gridSystem.isValid(vGridX, vGridZ)) {
                const cellType = this.gridSystem.getCell(vGridX, vGridZ);
                if (cellType === CellType.Goal) {
                    const targetX = vGridX + 0.5;
                    const targetZ = vGridZ + 0.5;
                    const dx = targetX - this.virtualPosition.x;
                    const dz = targetZ - this.virtualPosition.z;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist > 0.05) {
                        vxCommand = (dx / dist) * this.speed;
                        vzCommand = (dz / dist) * this.speed;
                    }
                } else {
                    const index = this.gridSystem.getFlatIndex(vGridX, vGridZ);
                    const targetAngle = solver.policy[index];
                    vxCommand = Math.cos(targetAngle) * this.speed;
                    vzCommand = Math.sin(targetAngle) * this.speed;

                    const centeringGain = 5.0; 
                    const isHorizontal = Math.abs(vxCommand) > Math.abs(vzCommand);
                    
                    if (isHorizontal) {
                        const targetZ = vGridZ + 0.5;
                        const errorZ = targetZ - (this.mode === 'mdp' ? this.position.z : this.virtualPosition.z);
                        vzCommand += errorZ * centeringGain;
                    } else {
                        const targetX = vGridX + 0.5;
                        const errorX = targetX - (this.mode === 'mdp' ? this.position.x : this.virtualPosition.x);
                        vxCommand += errorX * centeringGain;
                    }
                }
            }

            // --- Update Virtual Position ---
            this.virtualPosition.x += vxCommand * deltaTime;
            this.virtualPosition.z += vzCommand * deltaTime;

            // --- Calculate Real Forces (Physics) ---
            const rGridX = Math.floor(this.position.x);
            const rGridZ = Math.floor(this.position.z);
            
            if (this.gridSystem.isValid(rGridX, rGridZ) && this.gridSystem.getCell(rGridX, rGridZ) === CellType.Goal) {
                const targetX = rGridX + 0.5;
                const targetZ = rGridZ + 0.5;
                const dx = targetX - this.position.x;
                const dz = targetZ - this.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < 0.05) {
                    this.position.x = targetX;
                    this.position.z = targetZ;
                    this.isStopped = true;
                    this.stopReason = 'goal';
                }
            }

            const windVec = this.gridSystem.getWindVector(rGridX, rGridZ);
            let vxWind = 0;
            let vzWind = 0;
            
            if (Math.abs(windVec.x) > 0.01 || Math.abs(windVec.y) > 0.01) {
                const windMultiplier = 4.0;
                vxWind = windVec.x * windMultiplier;
                vzWind = windVec.y * windMultiplier;
            } else {
                vxWind += (Math.random() - 0.5) * 0.5;
                vzWind += (Math.random() - 0.5) * 0.5;
            }

            const totalVx = vxCommand + vxWind;
            const totalVz = vzCommand + vzWind;

            const radius = 0.05;
            const epsilon = 0.001;
            
            // --- X Axis Collision ---
            let nextX = this.position.x + totalVx * deltaTime;
            let checkX = totalVx > 0 ? nextX + radius : nextX - radius;
            let gridXCheck = Math.floor(checkX);
            let gridZCheck = Math.floor(this.position.z);
            
            if (!this.gridSystem.isValid(gridXCheck, gridZCheck) || this.gridSystem.getCell(gridXCheck, gridZCheck) === CellType.Wall) {
                if (totalVx > 0) nextX = gridXCheck - radius - epsilon;
                else nextX = gridXCheck + 1 + radius + epsilon;
                this.isStopped = true;
                this.stopReason = 'wall';
            }
            this.position.x = nextX;

            // --- Z Axis Collision ---
            let nextZ = this.position.z + totalVz * deltaTime;
            let checkZ = totalVz > 0 ? nextZ + radius : nextZ - radius;
            gridXCheck = Math.floor(this.position.x);
            gridZCheck = Math.floor(checkZ);
            
            if (!this.gridSystem.isValid(gridXCheck, gridZCheck) || this.gridSystem.getCell(gridXCheck, gridZCheck) === CellType.Wall) {
                if (totalVz > 0) nextZ = gridZCheck - radius - epsilon;
                else nextZ = gridZCheck + 1 + radius + epsilon;
                this.isStopped = true;
                this.stopReason = 'wall';
            }
            this.position.z = nextZ;

            // --- Rotation ---
            if (Math.abs(totalVx) > 0.1 || Math.abs(totalVz) > 0.1) {
                const targetPos = this.mesh.position.add(new Vector3(totalVx, 0, totalVz));
                this.mesh.lookAt(targetPos);
            }
        }

        // --- 3. Visual Updates (Always) ---
        this.updateTrail();
        this.updateMeshPosition();
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    private updateTrail(): void {
        if (this.visitedPath.length === 0) return;
        
        const livePos = this.position.clone();
        livePos.y = 0.03; // Trail always on ground
        const points = [...this.visitedPath, livePos];
        
        if (points.length < 2) return;

        // Ensure last two points are distinct enough for Babylon to render the tube
        const pLast = points[points.length - 2];
        const pCurr = points[points.length - 1];
        if (Vector3.DistanceSquared(pLast, pCurr) < 0.0001) return;

        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
        
        this.trailMesh = MeshBuilder.CreateTube("trail", {
            path: points,
            radius: 0.08, // Thicker trail
            tessellation: 8,
            cap: Mesh.NO_CAP,
            updatable: false 
        }, this.scene);
        
        this.trailMesh.material = this.trailMaterial;
        this.trailMesh.isPickable = false;
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.virtualPosition.copyFrom(this.position); 
        
        this.isStopped = false;
        this.stopReason = 'none';
        this.lastGridPos = { x, y };
        
        this.visitedPath = [new Vector3(x + 0.5, 0.03, y + 0.5)];
        if (this.trailMesh) {
            this.trailMesh.dispose();
            this.trailMesh = null;
        }
        
        this.updateMeshPosition();
    }

    public dispose(): void {
        this.mesh.dispose();
        if (this.trailMesh) {
            this.trailMesh.dispose();
        }
    }
}