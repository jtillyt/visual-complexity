import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Rover" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem; // Made public for access if needed
    private scene: Scene;
    public position: Vector3; // Made public for Solver access
    private speed: number = 8.0; // Units per second

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.5, startY + 0.5); // Center of tile, slightly up

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    private createMesh(): Mesh {
        const mesh = MeshBuilder.CreateBox("agent", { size: 0.6 }, this.scene);
        const material = new StandardMaterial("agentMat", this.scene);
        material.emissiveColor = new Color3(0.3, 0.7, 1.0); // Light Neon Blue
        material.disableLighting = true;
        mesh.material = material;
        return mesh;
    }

    /**
     * Updates the agent's position based on the policy field.
     * @param deltaTime Time elapsed since last frame in seconds.
     * @param solver The active solver providing the policy.
     */
    public update(deltaTime: number, solver: Solver): void {
        // 1. Get current grid cell
        const gridX = Math.floor(this.position.x);
        const gridZ = Math.floor(this.position.z);

        if (!this.gridSystem.isValid(gridX, gridZ)) {
            return;
        }

        const cellType = this.gridSystem.getCell(gridX, gridZ);

        // 2. Behavior based on cell type
        if (cellType === CellType.Goal) {
            this.mesh.rotation.y += 5 * deltaTime;
            return;
        }

        // 3. Base Movement from Policy
        const index = this.gridSystem.getFlatIndex(gridX, gridZ);
        const targetAngle = solver.policy[index];
        
        // Base Velocity vector (Policy direction * Agent Speed)
        let vx = Math.cos(targetAngle) * this.speed;
        let vz = Math.sin(targetAngle) * this.speed;

        // 4. Apply Environmental Forces
        if (cellType === CellType.Wind) {
            const wind = this.gridSystem.getWindConfig(gridX, gridZ);
            if (wind) {
                // Wind Force: Force units * Multiplier
                // A force of 1 should be significant.
                // If Agent speed is 8, and Wind Force is 2.
                // We want Wind to be able to overpower agent.
                // Let's say 1 Force unit = 2 units of speed.
                const windMultiplier = 4.0; 
                vx += wind.dx * wind.force * windMultiplier;
                vz += wind.dy * wind.force * windMultiplier;
            } else {
                // Fallback turbulence
                vx += (Math.random() - 0.5) * 5.0;
                vz += (Math.random() - 0.5) * 5.0;
            }
        } else {
             // Minor organic jitter
             vx += (Math.random() - 0.5) * 0.5;
             vz += (Math.random() - 0.5) * 0.5;
        }

        // 5. Integrate Position
        const nextX = this.position.x + vx * deltaTime;
        const nextZ = this.position.z + vz * deltaTime;

        // 6. Wall Collision (Simple Check)
        const nextGridX = Math.floor(nextX);
        const nextGridZ = Math.floor(nextZ);
        
        // Prevent moving into walls
        if (this.gridSystem.isValid(nextGridX, nextGridZ)) {
             const nextCell = this.gridSystem.getCell(nextGridX, nextGridZ);
             if (nextCell !== CellType.Wall) {
                 this.position.x = nextX;
                 this.position.z = nextZ;
             }
        }

        this.updateMeshPosition();
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.updateMeshPosition();
    }
}
