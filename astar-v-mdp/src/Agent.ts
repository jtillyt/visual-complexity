import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Rover" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem; // Made public for access if needed
    private scene: Scene;
    public position: Vector3; // Made public for Solver access
    private speed: number = 8.0; // Units per second

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.5, startY + 0.5); // Center of tile, slightly up

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    private createMesh(): Mesh {
        const mesh = MeshBuilder.CreateBox("agent", { size: 0.6 }, this.scene);
        const material = new StandardMaterial("agentMat", this.scene);
        material.emissiveColor = new Color3(0.3, 0.7, 1.0); // Light Neon Blue
        material.disableLighting = true;
        mesh.material = material;
        return mesh;
    }

    /**
     * Updates the agent's position based on the policy field.
     * @param deltaTime Time elapsed since last frame in seconds.
     * @param solver The active solver providing the policy.
     */
    public update(deltaTime: number, solver: Solver): void {
        // 1. Get current grid cell
        const gridX = Math.floor(this.position.x);
        const gridZ = Math.floor(this.position.z);

        if (!this.gridSystem.isValid(gridX, gridZ)) {
            return;
        }

        const cellType = this.gridSystem.getCell(gridX, gridZ);

        // 2. Behavior based on cell type
        if (cellType === CellType.Goal) {
            this.mesh.rotation.y += 5 * deltaTime;
            return;
        }

        // 3. Base Movement from Policy
        const index = this.gridSystem.getFlatIndex(gridX, gridZ);
        const targetAngle = solver.policy[index];
        
        // Base Velocity vector (Policy direction * Agent Speed)
        let vx = Math.cos(targetAngle) * this.speed;
        let vz = Math.sin(targetAngle) * this.speed;

        // 4. Apply Environmental Forces (Wind Field)
        const windVec = this.gridSystem.getWindVector(gridX, gridZ);
        const hasWind = (Math.abs(windVec.x) > 0.01 || Math.abs(windVec.y) > 0.01);

        if (hasWind) {
            const windMultiplier = 4.0;
            vx += windVec.x * windMultiplier;
            vz += windVec.y * windMultiplier;
        } else {
             // Minor organic jitter when no wind
             vx += (Math.random() - 0.5) * 0.5;
             vz += (Math.random() - 0.5) * 0.5;
        }

        // 5. Integrate Position
        const nextX = this.position.x + vx * deltaTime;
        const nextZ = this.position.z + vz * deltaTime;

        // 6. Wall Collision (Simple Check)
        const nextGridX = Math.floor(nextX);
        const nextGridZ = Math.floor(nextZ);
        
        // Prevent moving into walls
        if (this.gridSystem.isValid(nextGridX, nextGridZ)) {
             const nextCell = this.gridSystem.getCell(nextGridX, nextGridZ);
             if (nextCell !== CellType.Wall) {
                 this.position.x = nextX;
                 this.position.z = nextZ;
             }
        }

        this.updateMeshPosition();
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.updateMeshPosition();
    }
}
