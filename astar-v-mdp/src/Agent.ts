import { Scene } from '@babylonjs/core/scene';
import { MeshBuilder } from '@babylonjs/core/Meshes/meshBuilder';
import { Mesh } from '@babylonjs/core/Meshes/mesh';
import { Vector3 } from '@babylonjs/core/Maths/math.vector';
import { StandardMaterial } from '@babylonjs/core/Materials/standardMaterial';
import { Color3 } from '@babylonjs/core/Maths/math.color';
import { GridSystem, CellType } from './GridSystem';
import type { Solver } from './Solver';

/**
 * Agent represents the "Rover" exploring the grid.
 * It follows the policy field generated by the active Solver.
 */
export class Agent {
    private mesh: Mesh;
    public gridSystem: GridSystem; // Made public for access if needed
    private scene: Scene;
    public position: Vector3; // Made public for Solver access
    private speed: number = 8.0; // Units per second

    constructor(gridSystem: GridSystem, scene: Scene, startX: number, startY: number) {
        this.gridSystem = gridSystem;
        this.scene = scene;
        this.position = new Vector3(startX + 0.5, 0.5, startY + 0.5); // Center of tile, slightly up

        this.mesh = this.createMesh();
        this.updateMeshPosition();
    }

    private createMesh(): Mesh {
        const mesh = MeshBuilder.CreateBox("agent", { size: 0.6 }, this.scene);
        const material = new StandardMaterial("agentMat", this.scene);
        material.emissiveColor = new Color3(0.3, 0.7, 1.0); // Light Neon Blue
        material.disableLighting = true;
        mesh.material = material;
        return mesh;
    }

    /**
     * Updates the agent's position based on the policy field.
     * @param deltaTime Time elapsed since last frame in seconds.
     * @param solver The active solver providing the policy.
     */
    public update(deltaTime: number, solver: Solver): void {
        // 1. Get current grid cell
        const gridX = Math.floor(this.position.x);
        const gridZ = Math.floor(this.position.z);

        if (!this.gridSystem.isValid(gridX, gridZ)) {
            return;
        }

        const cellType = this.gridSystem.getCell(gridX, gridZ);

        // 2. Behavior based on cell type
        if (cellType === CellType.Goal) {
            // Spin to celebrate
            this.mesh.rotation.y += 5 * deltaTime;
            return;
        }

        // 3. Get Policy Angle
        const index = this.gridSystem.getFlatIndex(gridX, gridZ);
        const targetAngle = solver.policy[index];

        // 4. Calculate Velocity
        let vx = Math.cos(targetAngle);
        let vz = Math.sin(targetAngle);

        // 5. Apply Wind (Invisible Trap)
        if (cellType === CellType.Wind) {
            // Get specific config
            const wind = this.gridSystem.getWindConfig(gridX, gridZ);
            if (wind) {
                // Apply strong force in wind direction
                // "Offset to be outside the vector" -> We interpret this as a strong push
                // The force is "how many blocks of offset".
                // Let's add a massive velocity component.
                const windSpeed = wind.force * 5.0; // Arbitrary multiplier to make it feel like a "gust"
                vx += wind.dx * windSpeed;
                vz += wind.dy * windSpeed;
            } else {
                // Default fallback if no config (shouldn't happen with new UI)
                vx += (Math.random() - 0.5) * 3.0;
                vz += (Math.random() - 0.5) * 3.0;
            }
        } else {
             // Slight jitter for organic feel
             vx += (Math.random() - 0.5) * 0.2;
             vz += (Math.random() - 0.5) * 0.2;
        }

        // Normalize speed (unless it's wind chaos, which can be faster/slower)
        // actually if wind is pushing, we want to go fast.
        // So we won't normalize if wind is active.
        
        // Let's simplify:
        // Base velocity
        const baseSpeed = this.speed * deltaTime;
        let finalX = this.position.x + Math.cos(targetAngle) * baseSpeed;
        let finalZ = this.position.z + Math.sin(targetAngle) * baseSpeed;
        
        if (cellType === CellType.Wind) {
            const wind = this.gridSystem.getWindConfig(gridX, gridZ);
            if (wind) {
                 // Push agent by (Force * BlockSize) per second?
                 // Or just Push = Force * Speed?
                 // User said "Force (how many blocks of offset)".
                 // Let's say force 1 = 1 block / sec extra speed?
                 // Or force 1 = 1 block displacement PER FRAME? That's teleportation.
                 // "When the rover comes within... it should be offset".
                 // Let's do a strong push: Force * 5 * deltaTime.
                 finalX += wind.dx * wind.force * 5.0 * deltaTime;
                 finalZ += wind.dy * wind.force * 5.0 * deltaTime;
            }
        } else {
             // Add small noise
             finalX += (Math.random() - 0.5) * 0.2 * baseSpeed;
             finalZ += (Math.random() - 0.5) * 0.2 * baseSpeed;
        }

        const nextX = finalX;
        const nextZ = finalZ;

        // Simple wall collision check (center point)
        const nextGridX = Math.floor(nextX);
        const nextGridZ = Math.floor(nextZ);
        
        // Prevent moving into walls
        if (this.gridSystem.isValid(nextGridX, nextGridZ)) {
             const nextCell = this.gridSystem.getCell(nextGridX, nextGridZ);
             if (nextCell !== CellType.Wall) {
                 this.position.x = nextX;
                 this.position.z = nextZ;
             }
        }

        this.updateMeshPosition();
    }

    private updateMeshPosition(): void {
        this.mesh.position.copyFrom(this.position);
    }
    
    public setPosition(x: number, y: number) {
        this.position.x = x + 0.5;
        this.position.z = y + 0.5;
        this.updateMeshPosition();
    }
}
